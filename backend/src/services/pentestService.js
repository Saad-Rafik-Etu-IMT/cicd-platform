const axios = require('axios')
const { exec } = require('child_process')
const { promisify } = require('util')

const execAsync = promisify(exec)

// Pentest configuration
const TARGET_URL = process.env.PENTEST_TARGET_URL || 'http://localhost:8080'
const ZAP_API_URL = process.env.ZAP_API_URL || 'http://zap:8080'
const ZAP_API_KEY = process.env.ZAP_API_KEY || ''

class PentestService {
  constructor() {
    this.targetUrl = TARGET_URL
    this.zapUrl = ZAP_API_URL
    this.zapApiKey = ZAP_API_KEY
  }

  /**
   * Check if OWASP ZAP is available
   */
  async isZapAvailable() {
    try {
      const response = await axios.get(
        `${this.zapUrl}/JSON/core/view/version/`,
        { 
          params: { apikey: this.zapApiKey },
          timeout: 5000 
        }
      )
      return !!response.data.version
    } catch (error) {
      return false
    }
  }

  /**
   * Run OWASP ZAP Spider scan
   */
  async runSpiderScan(targetUrl) {
    try {
      // Start spider scan
      const startResponse = await axios.get(
        `${this.zapUrl}/JSON/spider/action/scan/`,
        {
          params: {
            apikey: this.zapApiKey,
            url: targetUrl,
            maxChildren: 10,
            recurse: true
          }
        }
      )
      
      const scanId = startResponse.data.scan
      
      // Wait for spider to complete
      let progress = 0
      while (progress < 100) {
        await new Promise(resolve => setTimeout(resolve, 2000))
        
        const statusResponse = await axios.get(
          `${this.zapUrl}/JSON/spider/view/status/`,
          { params: { apikey: this.zapApiKey, scanId } }
        )
        progress = parseInt(statusResponse.data.status)
      }
      
      return { success: true, scanId }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  /**
   * Run OWASP ZAP Active Scan
   */
  async runActiveScan(targetUrl) {
    try {
      // Start active scan
      const startResponse = await axios.get(
        `${this.zapUrl}/JSON/ascan/action/scan/`,
        {
          params: {
            apikey: this.zapApiKey,
            url: targetUrl,
            recurse: true,
            inScopeOnly: false
          }
        }
      )
      
      const scanId = startResponse.data.scan
      
      // Wait for scan to complete (with timeout)
      let progress = 0
      let attempts = 0
      const maxAttempts = 60 // 2 minutes max
      
      while (progress < 100 && attempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, 2000))
        
        const statusResponse = await axios.get(
          `${this.zapUrl}/JSON/ascan/view/status/`,
          { params: { apikey: this.zapApiKey, scanId } }
        )
        progress = parseInt(statusResponse.data.status)
        attempts++
      }
      
      return { success: true, scanId, completed: progress >= 100 }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  /**
   * Get ZAP scan alerts/vulnerabilities
   */
  async getAlerts(targetUrl) {
    try {
      const response = await axios.get(
        `${this.zapUrl}/JSON/core/view/alerts/`,
        {
          params: {
            apikey: this.zapApiKey,
            baseurl: targetUrl,
            start: 0,
            count: 100
          }
        }
      )
      
      return {
        success: true,
        alerts: response.data.alerts || []
      }
    } catch (error) {
      return { success: false, error: error.message, alerts: [] }
    }
  }

  /**
   * Get ZAP HTML report
   */
  async getHtmlReport() {
    try {
      const response = await axios.get(
        `${this.zapUrl}/OTHER/core/other/htmlreport/`,
        { params: { apikey: this.zapApiKey } }
      )
      return { success: true, report: response.data }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  /**
   * Run basic security checks without ZAP
   */
  async runBasicSecurityChecks(targetUrl) {
    const results = {
      checks: [],
      passed: 0,
      failed: 0,
      warnings: 0
    }

    // Check 1: HTTPS availability
    try {
      const httpsUrl = targetUrl.replace('http://', 'https://')
      await axios.get(httpsUrl, { timeout: 5000 })
      results.checks.push({
        name: 'HTTPS Available',
        status: 'passed',
        severity: 'info',
        description: 'Application is accessible via HTTPS'
      })
      results.passed++
    } catch {
      results.checks.push({
        name: 'HTTPS Available',
        status: 'warning',
        severity: 'medium',
        description: 'HTTPS not available or not configured'
      })
      results.warnings++
    }

    // Check 2: Security Headers
    try {
      const response = await axios.get(targetUrl, { timeout: 5000 })
      const headers = response.headers

      const securityHeaders = [
        { name: 'X-Content-Type-Options', expected: 'nosniff' },
        { name: 'X-Frame-Options', expected: ['DENY', 'SAMEORIGIN'] },
        { name: 'X-XSS-Protection', expected: '1' },
        { name: 'Strict-Transport-Security', expected: null },
        { name: 'Content-Security-Policy', expected: null }
      ]

      for (const header of securityHeaders) {
        const value = headers[header.name.toLowerCase()]
        if (value) {
          results.checks.push({
            name: `Security Header: ${header.name}`,
            status: 'passed',
            severity: 'info',
            description: `Header present: ${value}`
          })
          results.passed++
        } else {
          results.checks.push({
            name: `Security Header: ${header.name}`,
            status: 'warning',
            severity: 'low',
            description: `Missing security header: ${header.name}`
          })
          results.warnings++
        }
      }
    } catch (error) {
      results.checks.push({
        name: 'Security Headers Check',
        status: 'failed',
        severity: 'high',
        description: `Could not connect to target: ${error.message}`
      })
      results.failed++
    }

    // Check 3: Common sensitive paths
    const sensitivePaths = [
      '/.env',
      '/.git/config',
      '/wp-admin',
      '/phpinfo.php',
      '/server-status',
      '/.htaccess',
      '/web.config',
      '/backup.sql',
      '/dump.sql'
    ]

    for (const path of sensitivePaths) {
      try {
        const response = await axios.get(`${targetUrl}${path}`, { 
          timeout: 3000,
          validateStatus: status => status < 500
        })
        
        if (response.status === 200) {
          results.checks.push({
            name: `Sensitive Path Exposed: ${path}`,
            status: 'failed',
            severity: 'high',
            description: `Sensitive file/path is accessible: ${path}`
          })
          results.failed++
        }
      } catch {
        // Path not accessible - this is good
      }
    }

    // Check 4: Information disclosure
    try {
      const response = await axios.get(targetUrl, { timeout: 5000 })
      const serverHeader = response.headers['server']
      const poweredBy = response.headers['x-powered-by']

      if (serverHeader && serverHeader.includes('/')) {
        results.checks.push({
          name: 'Server Version Disclosure',
          status: 'warning',
          severity: 'low',
          description: `Server header reveals version: ${serverHeader}`
        })
        results.warnings++
      }

      if (poweredBy) {
        results.checks.push({
          name: 'X-Powered-By Disclosure',
          status: 'warning',
          severity: 'low',
          description: `Technology stack revealed: ${poweredBy}`
        })
        results.warnings++
      }
    } catch {
      // Ignore
    }

    return results
  }

  /**
   * Run full penetration test
   */
  async runFullPentest(targetUrl, options = {}) {
    const { useZap = true, quickScan = true } = options
    
    const report = {
      targetUrl,
      startTime: new Date().toISOString(),
      endTime: null,
      zapAvailable: false,
      vulnerabilities: {
        high: 0,
        medium: 0,
        low: 0,
        informational: 0
      },
      alerts: [],
      basicChecks: null,
      summary: ''
    }

    // Run basic security checks first
    report.basicChecks = await this.runBasicSecurityChecks(targetUrl)

    // Try ZAP if available and requested
    if (useZap) {
      report.zapAvailable = await this.isZapAvailable()
      
      if (report.zapAvailable) {
        // Run spider scan
        await this.runSpiderScan(targetUrl)
        
        // Run active scan if not quick mode
        if (!quickScan) {
          await this.runActiveScan(targetUrl)
        }
        
        // Get alerts
        const alertsResult = await this.getAlerts(targetUrl)
        if (alertsResult.success) {
          report.alerts = alertsResult.alerts
          
          // Count by risk level
          for (const alert of report.alerts) {
            switch (alert.risk) {
              case 'High': report.vulnerabilities.high++; break
              case 'Medium': report.vulnerabilities.medium++; break
              case 'Low': report.vulnerabilities.low++; break
              default: report.vulnerabilities.informational++
            }
          }
        }
      }
    }

    report.endTime = new Date().toISOString()
    
    // Generate summary
    const totalVulns = report.vulnerabilities.high + 
                       report.vulnerabilities.medium + 
                       report.vulnerabilities.low
    
    if (report.vulnerabilities.high > 0) {
      report.summary = `CRITICAL: ${report.vulnerabilities.high} high-risk vulnerabilities found`
    } else if (report.vulnerabilities.medium > 0) {
      report.summary = `WARNING: ${report.vulnerabilities.medium} medium-risk vulnerabilities found`
    } else if (totalVulns > 0) {
      report.summary = `${totalVulns} low-risk issues found`
    } else {
      report.summary = 'No significant vulnerabilities detected'
    }

    return report
  }

  /**
   * Simulate penetration test (for demo mode)
   */
  simulatePentest(targetUrl) {
    const simulatedAlerts = [
      {
        name: 'X-Frame-Options Header Not Set',
        risk: 'Medium',
        confidence: 'Medium',
        description: 'X-Frame-Options header is not included in the HTTP response',
        solution: 'Add X-Frame-Options header with DENY or SAMEORIGIN value'
      },
      {
        name: 'Cookie Without Secure Flag',
        risk: 'Low',
        confidence: 'Medium', 
        description: 'A cookie has been set without the secure flag',
        solution: 'Set the secure flag for all cookies'
      },
      {
        name: 'Server Leaks Version Information',
        risk: 'Low',
        confidence: 'High',
        description: 'Server header reveals version information',
        solution: 'Configure server to hide version information'
      }
    ]

    const basicChecks = {
      checks: [
        { name: 'HTTPS Available', status: 'passed', severity: 'info', description: 'HTTPS is properly configured' },
        { name: 'Security Header: X-Content-Type-Options', status: 'passed', severity: 'info', description: 'Header present: nosniff' },
        { name: 'Security Header: X-Frame-Options', status: 'warning', severity: 'low', description: 'Missing security header' },
        { name: 'Security Header: Content-Security-Policy', status: 'warning', severity: 'medium', description: 'Missing CSP header' },
        { name: 'Sensitive Path: /.env', status: 'passed', severity: 'info', description: 'Not accessible' },
        { name: 'Sensitive Path: /.git/config', status: 'passed', severity: 'info', description: 'Not accessible' }
      ],
      passed: 4,
      failed: 0,
      warnings: 2
    }

    return {
      targetUrl,
      startTime: new Date(Date.now() - 30000).toISOString(),
      endTime: new Date().toISOString(),
      zapAvailable: false,
      vulnerabilities: {
        high: 0,
        medium: 1,
        low: 2,
        informational: 3
      },
      alerts: simulatedAlerts,
      basicChecks,
      summary: 'WARNING: 1 medium-risk vulnerability found'
    }
  }

  /**
   * Generate pentest report for pipeline
   */
  generatePipelineReport(pentestResult) {
    const { vulnerabilities, basicChecks, summary, alerts } = pentestResult
    
    let report = `ðŸ” Security Scan Complete\n`
    report += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`
    
    // Vulnerability summary
    report += `ðŸ“Š Vulnerability Summary:\n`
    report += `   ðŸ”´ High:   ${vulnerabilities.high}\n`
    report += `   ðŸŸ  Medium: ${vulnerabilities.medium}\n`
    report += `   ðŸŸ¡ Low:    ${vulnerabilities.low}\n`
    report += `   ðŸ”µ Info:   ${vulnerabilities.informational}\n\n`
    
    // Basic checks summary
    if (basicChecks) {
      report += `ðŸ›¡ï¸ Security Checks:\n`
      report += `   âœ… Passed:   ${basicChecks.passed}\n`
      report += `   âš ï¸ Warnings: ${basicChecks.warnings}\n`
      report += `   âŒ Failed:   ${basicChecks.failed}\n\n`
    }
    
    // Top alerts
    if (alerts && alerts.length > 0) {
      report += `âš ï¸ Top Issues:\n`
      alerts.slice(0, 5).forEach((alert, i) => {
        const riskIcon = alert.risk === 'High' ? 'ðŸ”´' : 
                         alert.risk === 'Medium' ? 'ðŸŸ ' : 'ðŸŸ¡'
        report += `   ${i + 1}. ${riskIcon} ${alert.name}\n`
      })
      report += '\n'
    }
    
    report += `ðŸ“‹ Result: ${summary}`
    
    return report
  }
}

module.exports = new PentestService()
